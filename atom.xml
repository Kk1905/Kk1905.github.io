<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李可可 | 个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://itblogs.club/"/>
  <updated>2019-11-18T08:08:32.477Z</updated>
  <id>http://itblogs.club/</id>
  
  <author>
    <name>KkkBoy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> 从synchronized 到CAS 和 AQS彻底弄懂Java各种并发锁 </title>
    <link href="http://itblogs.club/2019/11/12/%E4%BB%8Esynchronized-%E5%88%B0CAS-%E5%92%8C-AQS%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Java%E5%90%84%E7%A7%8D%E5%B9%B6%E5%8F%91%E9%94%81/"/>
    <id>http://itblogs.club/2019/11/12/从synchronized-到CAS-和-AQS彻底弄懂Java各种并发锁/</id>
    <published>2019-11-12T09:20:42.000Z</published>
    <updated>2019-11-18T08:08:32.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 中的并发锁大致分为隐式锁和显式锁两种。隐式锁就是我们最常使用的 synchronized 关键字，显式锁主要包含两个接口：Lock 和 ReadWriteLock，主要实现类分别为 ReentrantLock 和 ReentrantReadWriteLock，这两个类都是基于 AQS(AbstractQueuedSynchronizer) 实现的。还有的地方将 CAS 也称为一种锁，在包括 AQS 在内的很多并发相关类中，CAS 都扮演了很重要的角色。</p><p>我们只需要弄清楚 synchronized 和 AQS 的原理，再去理解并发锁的性质和局限就很简单了。因此这篇文章重点放在原理上，对于使用和特点不会过多涉及。</p><h1 id="锁的概念辨析"><a href="#锁的概念辨析" class="headerlink" title="锁的概念辨析"></a>锁的概念辨析</h1><p>下面是关于锁的一些概念解释，这些都是一些关于锁的性质的描述，并非具体实现。</p><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>悲观锁和独占锁是一个意思，它假设一定会发生冲突，因此获取到锁之后会阻塞其他等待线程。这么做的好处是简单安全，但是挂起线程和恢复线程都需要转入内核态进行，这样做会带来很大的性能开销。悲观锁的代表是 synchronized。然而在真实环境中，大部分时候都不会产生冲突。悲观锁会造成很大的浪费。而乐观锁不一样，它假设不会产生冲突，先去尝试执行某项操作，失败了再进行其他处理（一般都是不断循环重试）。这种锁不会阻塞其他的线程，也不涉及上下文切换，性能开销小。代表实现是 CAS。</p><a id="more"></a><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁是指各个线程在加锁前先检查有无排队的线程，按排队顺序去获得锁。</p><p>非公平锁是指线程加锁前不考虑排队问题，直接尝试获取锁，获取不到再去队尾排队。值得注意的是，在 AQS 的实现中，一旦线程进入排队队列，即使是非公平锁，线程也得乖乖排队。</p><h2 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h2><p>如果一个线程已经获取到了一个锁，那么它可以访问被这个锁锁住的所有代码块。不可重入锁与之相反。</p><h1 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a>Synchronized 关键字</h1><p>Synchronized 是一种<strong>可重入的</strong>、<strong>非公平的</strong>、<strong>独占的</strong>并且<strong>重量级的</strong>锁。</p><ul><li>在修饰静态方法时，锁的是类对象，如 Object.class。</li><li>修饰非静态方法时，锁的是对象，即 this。</li><li>修饰方法块时，锁的是括号里的对象。</li></ul><p>每个对象有一个<strong>锁</strong>和一个<strong>等待队列</strong>，锁只能被一个线程持有，其他需要锁的线程需要阻塞等待。锁被释放后，对象会从队列中取出一个并唤醒，唤醒哪个线程是不确定的，不保证公平性。</p><p>多个线程是可以同时执行同一个synchronized实例方法的，只要它们访问的对象是不同的，也就是说它们获取的根本不是同一个对象锁。</p><p>synchronized 锁住的是对象而非代码，只要访问的是同一个对象的 synchronized 方法，即使是不同的代码，也会被同步顺序访问。</p><p>此外，需要说明的，synchronized方法不能防止非synchronized方法被同时执行，所以，一般在保护变量时，需要在所有访问该变量的方法上加上synchronized。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>synchronized 是基于 <strong>Monitor</strong> 机制和 JVM 对象头中的<strong>Mark Word</strong>和来实现的。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>一个对象在堆内存中包含三部分：对象头，实例数据和对齐填充。其中对象头包含两部分（第二部分视具体情况而定）：</p><ol><li>Mark Word（标记字段）：存出一些对象自身运行时的数据，包括哈希码，GC 分代年龄，锁状态标志等。</li><li>Class Metadata Address （类型指针）：存储类的元数据的指针。虚拟机通过这个指针找到它是哪个类的实例。</li></ol><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Mark Word 中有一个字段指向 monitor 对象的内存地址。monitor 中记录了锁的持有线程，等待的线程队列等信息。前面说的每个对象都有一个锁和一个等待队列，就是在这里实现的。</p><p>monitor 对象由 C++ 实现。其中有三个关键字段：</p><ul><li><em>owner 记录当前持有锁的线程</em></li><li>EntryList 是一个队列，记录所有阻塞等待锁的线程</li><li>_WaitSet 也是一个队列，记录调用 wait() 方法并还未被通知的线程。</li></ul><p>Monitor的操作机制如下：</p><p>多个线程竞争锁时，会先进入 EntryList 队列。竞争成功的线程被标记为 Owner。其他线程继续在此队列中阻塞等待。</p><p>如果 Owner 线程调用 wait() 方法，则其释放对象锁并进入 WaitSet 中等待被唤醒。Owner 被置空，EntryList 中的线程再次竞争锁。</p><p>如果 Owner 线程执行完了，便会释放锁，Owner 被置空，EntryList 中的线程再次竞争锁。</p><h3 id="JVM-对-synchronized-的处理"><a href="#JVM-对-synchronized-的处理" class="headerlink" title="JVM 对 synchronized 的处理"></a>JVM 对 synchronized 的处理</h3><p>上面了解了 monitor 的机制，那虚拟机是如何将 synchronized 和 monitor 关联起来的呢？分两种情况：</p><ol><li>如果同步的是代码块，编译时会直接在同步代码块前加上 monitorenter 指令，代码块后加上 monitorexit 指令。这称为显示同步。</li><li>如果同步的是方法，虚拟机会为方法设置 ACC_SYNCHRONIZED 标志。调用的时候 JVM 根据这个标志判断是否是同步方法。</li></ol><h3 id="JVM-对-synchronized-的优化"><a href="#JVM-对-synchronized-的优化" class="headerlink" title="JVM 对 synchronized 的优化"></a>JVM 对 synchronized 的优化</h3><p>synchronized 是重量级锁，由于消耗太大，虚拟机对其做了一些优化。</p><h4 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h4><p>在许多应用中，锁定状态只会持续很短的时间，为了这么一点时间去挂起恢复线程，不值得。我们可以让等待线程执行一定次数的循环，在循环中去获取锁。这项技术称为自旋锁，它可以节省系统切换线程的消耗，但仍然要占用处理器。在 JDK1.4.2 中，自选的次数可以通过参数来控制。 JDK 1.6又引入了自适应的自旋锁，不再通过次数来限制，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>虚拟机在运行时，如果发现一段被锁住的代码中不可能存在共享数据，就会将这个锁清除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>当虚拟机检测到有一串零碎的操作都对同一个对象加锁时，会把锁扩展到整个操作序列外部。如 StringBuffer 的 append 操作。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>对绝大部分的锁来说，在整个同步周期内都不存在竞争。如果没有竞争，轻量级锁可以使用 CAS 操作避免使用互斥量的开销。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁。</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="操作模型"><a href="#操作模型" class="headerlink" title="操作模型"></a>操作模型</h2><p>CAS 是 compare and swap 的简写，即比较并交换。它是指一种操作机制，而不是某个具体的类或方法。在 Java 平台上对这种操作进行了包装。在 Unsafe 类中，调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br></pre></td></tr></table></figure><p>它需要三个参数，分别是内存位置 V，旧的预期值 A 和新的值 B。操作时，先从内存位置读取到值，然后和预期值A比较。如果相等，则将此内存位置的值改为新值 B，返回 true。如果不相等，说明和其他线程冲突了，则不做任何改变，返回 false。</p><p>这种机制在不阻塞其他线程的情况下避免了并发冲突，比独占锁的性能高很多。 CAS 在 Java 的原子类和并发包中有大量使用。</p><h2 id="重试机制（循环-CAS）"><a href="#重试机制（循环-CAS）" class="headerlink" title="重试机制（循环 CAS）"></a>重试机制（循环 CAS）</h2><p><strong>有很多文章说，CAS 操作失败后会一直重试直到成功，这种说法很不严谨。</strong></p><p>第一，CAS 本身并未实现失败后的处理机制，它只负责返回成功或失败的布尔值，后续由调用者自行处理。只不过我们最常用的处理方式是重试而已。</p><p>第二，这句话很容易理解错，被理解成重新比较并交换。实际上失败的时候，原值已经被修改，如果不更改期望值，再怎么比较都会失败。而新值同样需要修改。</p><p>所以正确的方法是，使用一个死循环进行 CAS 操作，成功了就结束循环返回，失败了就重新从内存读取值和计算新值，再调用 CAS。看下 AtomicInteger 的源码就什么都懂了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="title">intincrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123; </span><br><span class="line">    <span class="keyword">int</span> current = get();</span><br><span class="line">    <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(compareAndSet(current, next))</span><br><span class="line">            returnnext;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>CAS 主要分三步，<strong>读取</strong>-<strong>比较</strong>-<strong>修改</strong>。其中比较是在检测是否有冲突，如果检测到没有冲突后，其他线程还能修改这个值，那么 CAS 还是无法保证正确性。所以最关键的是要保证<strong>比较-修改</strong>这两步操作的原子性。</p><p>CAS 底层是靠调用 CPU 指令集的 <em>cmpxchg</em> 完成的，它是 x86 和 Intel 架构中的 compare and exchange 指令。在多核的情况下，这个指令也不能保证原子性，需要在前面加上  lock 指令。lock 指令可以保证一个 CPU 核心在操作期间独占一片内存区域。那么 这又是如何实现的呢？</p><p>在处理器中，一般有两种方式来实现上述效果：总线锁和缓存锁。在多核处理器的结构中，CPU 核心并不能直接访问内存，而是统一通过一条总线访问。总线锁就是锁住这条总线，使其他核心无法访问内存。这种方式代价太大了，会导致其他核心停止工作。而缓存锁并不锁定总线，只是锁定某部分内存区域。当一个 CPU 核心将内存区域的数据读取到自己的缓存区后，它会锁定缓存对应的内存区域。锁住期间，其他核心无法操作这块内存区域。</p><p>CAS 就是通过这种方式实现比较和交换操作的原子性的。<strong>值得注意的是， CAS 只是保证了操作的原子性，并不保证变量的可见性，因此变量需要加上 volatile 关键字。</strong></p><h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><p>上面提到，CAS 保证了比较和交换的原子性。但是从读取到开始比较这段期间，其他核心仍然是可以修改这个值的。如果核心将 A 修改为 B，CAS 可以判断出来。但是如果核心将 A 修改为 B 再修改回 A。那么 CAS 会认为这个值并没有被改变，从而继续操作。这是和实际情况不符的。解决方案是加一个版本号。</p><h1 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁 ReentrantLock"></a>可重入锁 ReentrantLock</h1><p>ReentrantLock 使用代码实现了和 synchronized 一样的语义，它们都是可重入锁，并且都已经保证了内存<strong>可见性</strong>和解决竞态条件问题等。相比 synchronized，ReentrantLock有很多扩展功能，它基于AQS实现，并且它还有如下好处：</p><ul><li>支持以非阻塞方式获取锁</li><li>可以<strong>响应中断</strong></li><li>可以限时</li><li>同时支持了公平锁和非公平锁，通过构造方法传参控制，默认无参构造函数是非公平锁</li></ul><p>基本用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">voidincr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">intgetCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        returncount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 内部有两个内部类，分别是 <strong>FairSync</strong> 和 <strong>NoFairSync</strong>，对应公平锁和非公平锁。他们都继承自 Sync，而Sync 又继承自AQS。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS 全称 AbstractQueuedSynchronizer。AQS 中有两个重要的成员：</p><ul><li>成员变量 state，用于表示锁现在的状态，用 volatile 修饰，保证内存一致性。同时所用对 state 的操作都是使用 <strong>CAS</strong> 进行的。state 为0表示没有任何线程持有这个锁，线程持有该锁后将 state 加1，释放时减1。多次持有释放则多次加减。</li><li>还有一个<strong>双向链表</strong>，链表除了头结点外，每一个节点都记录了线程的信息，代表一个等待线程。这是一个 FIFO 的链表。</li></ul><p>下面以 ReentrantLock 非公平锁的代码看看 AQS 的原理。</p><h2 id="请求锁"><a href="#请求锁" class="headerlink" title="请求锁"></a>请求锁</h2><p>请求锁时有三种可能：</p><ol><li>如果没有线程持有锁，则请求成功，当前线程直接获取到锁。</li><li>如果当前线程已经持有锁，则使用 CAS 将 state 值加1，表示自己再次申请了锁，释放锁时减1。这就是可重入性的实现。</li><li>如果由其他线程持有锁，那么将自己添加进等待队列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="title">voidlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">//没有线程持有锁时，直接获取锁，对应情况1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryAcquire(arg)中，会判断当前持有线程是否等于自己，对应情况2</span></span><br><span class="line">    <span class="comment">//acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，将自己加入队列中，对应情况3 </span></span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Node-节点并加入链表"><a href="#创建-Node-节点并加入链表" class="headerlink" title="创建 Node 节点并加入链表"></a>创建 Node 节点并加入链表</h2><p>如果没竞争到锁，这时候就要进入等待队列。队列是默认有一个 head 节点的，并且不包含线程信息。上面情况3中，addWaiter 会创建一个 Node，并添加到链表的末尾，Node 中持有当前线程的引用。同时还有一个成员变量 waitStatus，表示线程的等待状态，初始值为0。我们还需要关注两个值：</p><ol><li>CANCELLED，值为1，表示取消状态，就是说我不要这个锁了，请你把我移出去。</li><li>SINGAL，值为-1，表示下一个节点正在挂起等待，注意是下一个节点，不是当前节点。</li></ol><p>同时，加到链表末尾的操作使用了 CAS+死循环的模式，很有代表性，拿出来看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    Node oldTail = tail;</span><br><span class="line">    <span class="keyword">if</span>(oldTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">        <span class="keyword">if</span>(compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">            oldTail.next = node;</span><br><span class="line">            returnnode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        initializeSyncQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在死循环里调用了 CAS 的方法。如果多个线程同时调用该方法，那么每次循环都只有一个线程执行成功，其他线程进入下一次循环，重新调用。N个线程就会循环N次。这样就在无锁的模式下实现了并发模型。</p><h2 id="挂起等待"><a href="#挂起等待" class="headerlink" title="挂起等待"></a>挂起等待</h2><p>如果此节点的上一个节点是头部节点，则再次尝试获取锁，获取到了就移除并返回。获取不到就进入下一步；</p><p>判断前一个节点的 waitStatus，如果是 SINGAL，则返回 true，并调用 LockSupport.park() 将线程挂起；</p><p>如果是 CANCELLED，则将前一个节点移除；</p><p>如果是其他值，则将前一个节点的 waitStatus 标记为 SINGAL，进入下一次循环。</p><p>可以看到，一个线程最多有两次机会，还竞争不到就去挂起等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted =<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">//helpGCreturninterrupted;            </span></span><br><span class="line">            &#125;<span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">                interrupted =<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>调用 tryRelease，此方法由子类实现。实现非常简单，如果当前线程是持有锁的线程，就将 state 减1。减完后如果 state 大于0，表示当前线程仍然持有锁，返回 false。如果等于0，表示已经没有线程持有锁，返回 true，进入下一步；</p><p>如果头部节点的 waitStatus 不等于0，则调用LockSupport.unpark()唤醒其下一个节点。头部节点的下一个节点就是等待队列中的第一个线程，这反映了 AQS 先进先出的特点。另外，即使是非公平锁，进入队列之后，还是得按顺序来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryRelease(arg)) &#123; <span class="comment">//将 state 减1</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        returntrue;</span><br><span class="line">    &#125;</span><br><span class="line">    returnfalse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws &lt; <span class="number">0</span>)</span><br><span class="line">        node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">            <span class="keyword">if</span>(p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = p;</span><br><span class="line">    &#125;<span class="keyword">if</span>(s != <span class="keyword">null</span>) <span class="comment">//唤醒第一个等待的线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁如何实现"><a href="#公平锁如何实现" class="headerlink" title="公平锁如何实现"></a>公平锁如何实现</h2><p>上面分析的是非公平锁，那公平锁呢？很简单，在竞争锁之前判断一下等待队列中有没有线程在等待就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断等待队列是否有节点 </span></span><br><span class="line">        <span class="keyword">if</span>(!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            returntrue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    returnfalse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可重入读写锁-ReentrantReadWriteLock"><a href="#可重入读写锁-ReentrantReadWriteLock" class="headerlink" title="可重入读写锁 ReentrantReadWriteLock"></a>可重入读写锁 ReentrantReadWriteLock</h1><h2 id="读写锁机制"><a href="#读写锁机制" class="headerlink" title="读写锁机制"></a>读写锁机制</h2><p>理解 ReentrantLock 和 AQS 之后，再来理解读写锁就很简单了。读写锁有一个读锁和一个写锁，分别对应读操作和锁操作。锁的特性如下：</p><p>只有一个线程可以获取到写锁。在获取写锁时，只有没有任何线程持有任何锁才能获取成功；</p><p>如果有线程正持有写锁，其他任何线程都获取不到任何锁；</p><p>没有线程持有写锁时，可以有多个线程获取到读锁。</p><p>上面锁的特点保证了可以并发读取，这大大提高了效率，在实际开发中非常有用。那么在具体是如何实现的呢？</p><h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p>读写锁虽然有两个锁，但实际上只有一个等待队列。</p><p>获取写锁时，要保证没有任何线程持有锁；</p><p>写锁释放后，会唤醒队列第一个线程，可能是读锁和写锁；</p><p>获取读锁时，先判断写锁有没有被持有，没有就可以获取成功；</p><p>获取读锁成功后，会将队列中等待读锁的线程挨个唤醒，知道遇到等待写锁的线程位置；</p><p>释放读锁时，要检查读锁数，如果为0，则唤醒队列中的下一个线程，否则不进行操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Java 中的并发锁大致分为隐式锁和显式锁两种。隐式锁就是我们最常使用的 synchronized 关键字，显式锁主要包含两个接口：Lock 和 ReadWriteLock，主要实现类分别为 ReentrantLock 和 ReentrantReadWriteLock，这两个类都是基于 AQS(AbstractQueuedSynchronizer) 实现的。还有的地方将 CAS 也称为一种锁，在包括 AQS 在内的很多并发相关类中，CAS 都扮演了很重要的角色。&lt;/p&gt;
&lt;p&gt;我们只需要弄清楚 synchronized 和 AQS 的原理，再去理解并发锁的性质和局限就很简单了。因此这篇文章重点放在原理上，对于使用和特点不会过多涉及。&lt;/p&gt;
&lt;h1 id=&quot;锁的概念辨析&quot;&gt;&lt;a href=&quot;#锁的概念辨析&quot; class=&quot;headerlink&quot; title=&quot;锁的概念辨析&quot;&gt;&lt;/a&gt;锁的概念辨析&lt;/h1&gt;&lt;p&gt;下面是关于锁的一些概念解释，这些都是一些关于锁的性质的描述，并非具体实现。&lt;/p&gt;
&lt;h2 id=&quot;悲观锁和乐观锁&quot;&gt;&lt;a href=&quot;#悲观锁和乐观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁和乐观锁&quot;&gt;&lt;/a&gt;悲观锁和乐观锁&lt;/h2&gt;&lt;p&gt;悲观锁和独占锁是一个意思，它假设一定会发生冲突，因此获取到锁之后会阻塞其他等待线程。这么做的好处是简单安全，但是挂起线程和恢复线程都需要转入内核态进行，这样做会带来很大的性能开销。悲观锁的代表是 synchronized。然而在真实环境中，大部分时候都不会产生冲突。悲观锁会造成很大的浪费。而乐观锁不一样，它假设不会产生冲突，先去尝试执行某项操作，失败了再进行其他处理（一般都是不断循环重试）。这种锁不会阻塞其他的线程，也不涉及上下文切换，性能开销小。代表实现是 CAS。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发" scheme="http://itblogs.club/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://itblogs.club/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java线程池实现原理</title>
    <link href="http://itblogs.club/2019/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://itblogs.club/2019/10/16/深入理解java线程池实现原理/</id>
    <published>2019-10-16T08:51:59.000Z</published>
    <updated>2019-11-18T09:21:48.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>说明一下，本文的全部分析基于<strong>JDK1.8</strong>，并且文章较长，需要一定的耐心。</p><p>让我们开始，首先来看本次所讲到的java线程池相关API的继承图：</p><img src="http://kk.itblogs.club/static/images/并发/线程池继承关系.jpg-original_wm"><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p><strong>Executor</strong>作为顶级接口，只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure><p>execute()方法可能会在新的线程中执行，也有可能会在线程池中的某个线程中执行，也有可能直接在调用者线程中执行，这一切都依赖于Executor的具体实现。Executor其实可以理解成一个“任务管理器”，比起你直接创建Thread然后执行任务，它会替你完成线程的创建以及任务的执行，乃至线程的回收等等，当然这一切都依赖于Executor的具体实现。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p><strong>ExecutorService</strong>接口继承了Executor，它是Executor接口重要的功能扩展，它抽象出了诸多方法，你大可把它当做真正的线程池接口，来看它的API截图：</p><a id="more"></a><img src="http://kk.itblogs.club/static/images/并发/ExecutorService_API定义.jpg-original"><h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><p><strong>AbstractExecutorService</strong>是一个抽象类，它实现了ExecutorService接口，并且ExecutorService中定义的大多数方法都在该类中得到了实现，比如submit()的几个重载方法以及跟invoke相关的一些方法等等，来看它的API截图：</p><img src="http://kk.itblogs.club/static/images/并发/AbstractExecutorService_API定义.jpg-original"><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><strong>ThreadPoolExecutor</strong>类是线程池中最核心的一个类，继承了AbstractExecutorService，它是线程池最具体的实现，因为它实现了Executor中所定义的execute()方法。对于该类的解析正是本文的重点。</p><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p><strong>Executors</strong>是一个工具类，线程池的静态工厂，它已经为大多数使用场景预设了线程池，提供了快捷创建线程池的静态方法。在平时使用线程池的过程中，大多是用Executors来直接创建。</p><h1 id="ThreadPoolExecutor解析"><a href="#ThreadPoolExecutor解析" class="headerlink" title="ThreadPoolExecutor解析"></a>ThreadPoolExecutor解析</h1><h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><p>ThreadPoolExecutor一共提供了四个public的构造方法，我们看它最重要的一个构造方法开始，因为其他三个最终都会调用到下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法着手的主要原因是为了去了解ThreadPoolExecutor里面的核心参数，下面一一讲解：</p><ul><li><p><strong>corePoolSize</strong>：线程池核心线程数</p><p>核心线程池大小描述的是通常情况下线程池中活跃的线程最小数量，一般来讲，一个线程池被创建后，它的初始线程个数是0。当有任务来的时候，就会创建线程执行任务，当池中的线程个数大于corePoolSize，就会将任务放入<em>工作队列(workQueue)</em>。</p></li><li><p><strong>maximumPoolSize</strong>：线程池最大线程数</p><p>当<em>阻塞队列</em>也放不下任务的时候，就会继续创建线程来执行任务，但是最终该池中的线程个数不能超出maximumPoolSize。</p></li><li><p><strong>keepAliveTime</strong>：线程保持活跃而不销毁的时间</p><p>一般来讲，keepAliveTime只会在线程个数超过corePoolSize的时候发挥作用，它会将线程保留keepAliveTime的时间，然后销毁，直到池中线程个数等于corePoolSize。但如果调用了allowCoreThreadTimeOut()方法，就相当于允许核心线程池中的线程也超时销毁，那么不管什么线程最终都会因为超出keepAliveTime时间而被销毁，直至最终线程个数为0。</p></li><li><p><strong>unit</strong>：TimeUnit类型，作为keepAliveTime的时间单位</p><p>其实这是一个很有意思的工具类，也是自java 1.5加入到java.util.concurrent包内的，它封装了一些对当前线程的操作，比如线程sleep就推荐用TimeUnit去写，这里我们只需关注它的七个时间枚举：    </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;              <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>workQueue</strong>：工作队列</p><p>当池中线程个数大于corePoolSize的时候，任务就存放于此等待执行。workQueue类型为BlockingQueue，jdk已经内置了几种实现，通常会取以下几种类型：</p><ol><li>ArrayBlockingQueue：有界队列，基于数组的先进先出队列，此队列创建时，需要指定大小</li><li>LinkedBlockingQueue：无界队列，基于链表的先进先出队列，如果创建时没有指定队列大小，则默认为Integer.MAX_VALUE。它其实间接的造成maximumPoolSize失效，同时也存在内存溢出的隐患</li><li>SynchronousQueue：任务不用排队而是直接提交的队列，该队列下任务过来会直接新建线程执行</li><li>PriorityBlockingQueue：和ArrayBlockingQueue差不多，不同的是它可以实现自动扩容，其中的元素要实现Comparatable接口，在创建时要传入comparator，这些都是用于元素的排序</li></ol></li><li><p><strong>threadFactory</strong>：线程工厂</p><p>线程工厂，顾名思义，就是用来生产线程的，它可以为线程设置一些属性，比如线程名、守护线程等，它还可以设置在主线程中对于子线程的未捕获异常的处理策略等等。一般来讲Executors中提供的默认线程工厂就足够了。</p></li><li><p><strong>handler</strong>：表示拒绝执行任务的策略</p><p>它是RejectedExecutionHandler类型的引用，它会在<strong>队列饱和</strong>或者<strong>线程池被关闭</strong>时被调用。RejectedExecutionHandler接口在ThreadPoolExecutor中有四种类型的内部实现类：</p><ol><li>ThreadPoolExecutor.AbortPolicy（默认）：丢弃任务，并抛出RejectedExecutionException异常</li><li>ThreadPoolExecutor.CallerRunsPolicy：用调用者的线程执行任务</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列中存在最久未被执行的任务，然后重新尝试execute执行，但如果线程池被关闭，任务会直接被丢弃</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，不会抛出异常</li></ol></li></ul><h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h2><p>在上面的众多参数中，最需要理解的是<strong>corePoolSize</strong>和<strong>maximumPoolSize</strong>，可以做一个总结就是：</p><ol><li>池中线程数小于corePoolSize，新任务过来会直接创建新线程来执行。 </li><li>池中线程数大于等于corePoolSize，且workQueue未饱和，新任务过来会加入workQueue等待执行。 </li><li>池中线程数大于等于corePoolSize，且workQueue已饱和，但线程数小于maximumPoolSize，新任务过来会创建新线程来执行。 </li><li>池中线程数大于等于corePoolSize，且workQueue已饱和，并且线程数等于maximumPoolSize，新任务会被拒绝，拒绝策略就是handler。 </li></ol><p>所以，在我们接下来要探究线程池的细枝末节之前，能够大体了解它的执行流程是很有帮助的，正如上面总结的，线程池的执行大体就是在围绕corePoolSize和maximumPoolSize在进行，大家也可以参考下图来有个更直观的印象：</p><img src="http://kk.itblogs.club/static/images/并发/线程池执行流程-2.png-original_wm"><h2 id="线程池状态：认识ctl"><a href="#线程池状态：认识ctl" class="headerlink" title="线程池状态：认识ctl"></a>线程池状态：认识ctl</h2><p>先来看下面ThreadPoolExecutor中很重要的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 线程数量占用的位数：32-3=29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 最大线程数，1*2的29次方再减1，足够大了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// 运行状态存储在高位（前三位），后面都是29个0</span></span><br><span class="line"><span class="comment">// 111（有符号）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 处理ctl的值，从中获取高3位得到线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 处理ctl的值，从中获取低29位得到线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 将runState(线程池状态)和workerCount(线程数量)通过 [按位或运算符] 合并成ctl的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don't require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 下面的三个方法从名字上也能猜出它在干嘛</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ctl是ThreadPoolExecutor的一个重要属性，它身兼两职，同时记录着线程池的<strong>线程数量</strong>和<strong>线程池状态</strong>。怎么做到的呢？从上面的代码可以看到，Integer.SIZE是32，COUNT_BITS是29，线程池状态均左移位29，所以通过ctl.get()获取的值，32位中，前三位用于表示线程池状态，后29位用于表示线程的数量。这样一来，一个变量就可以代表两种含义，这在很大程度上减少获取变量时锁的竞争。同时，<strong>AtomicInteger</strong>这个类是线程安全的，它可以通过<strong>CAS操作</strong>达到无锁并发，如果不清楚CAS是什么的，可以自行查阅资料。线程池的状态一共有五种：</p><ul><li>RUNNING：运行状态，也是线程池的初始状态，会接收新任务并处理队列中的任务</li><li>SHUTDOWN：停工状态，不再接收新任务，但正在执行的任务会继续执行，队列中的任务也会得到处理</li><li>STOP：停止状态，不再接收新任务，正在执行的任务会被中断并且队列中的任务不会被处理</li><li>TIDYING：清空状态，所有任务都停止，队列被清空，工作线程也全部销毁（workerCount=0），并且会接着调用terminated()方法</li><li>TERMINATED：终止状态，terminated()方法调用后到此状态，此时线程池被销毁</li></ul><h2 id="提交任务：execute"><a href="#提交任务：execute" class="headerlink" title="提交任务：execute()"></a>提交任务：execute()</h2><p>向线程池提交任务有这2种方式，execute()方法和submit()方法。上面我也说过submit()方法是<strong>ExecutorService</strong>接口中定义的，并且在<strong>AbstractExecutorService</strong>这个抽象类中就已得到实现。submit()方法主要是将任务封装成FutureTask的形式来提交，达到对任务进行监控的目的，比如中断任务的执行，获取执行结果等等，这一切的监控行为都是FutureTask自己维护的。submit()方法最终都会调用execute()方法，execute()方法是在ThreadPoolExecutor中实现的，来看下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一阶段：</span></span><br><span class="line"><span class="comment">     * 如果线程数量 &lt; 核心线程数量，就通过addWorker()新起线程执行任务，该线程占用corePoolSize个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果addWorker()成功，则execute()返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果addWorker()失败，则刷新ctl（ctl中保存了两个信息，线程池状态和线程个数，后面不再赘述）</span></span><br><span class="line"><span class="comment">         * 失败原因可能是：</span></span><br><span class="line"><span class="comment">         *     1.线程池状态是SHUTDOWN，此时不接收新任务</span></span><br><span class="line"><span class="comment">         *     2.并发的原因，导致workerCountOf(c) &gt;= corePoolSize</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第二阶段：</span></span><br><span class="line"><span class="comment">     * 如果线程池是RUNNING状态，并且任务添加队列成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 刷新ctl</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 双重校验线程池是否还是RUNNING状态，如果不是，则从队列中移除任务，并执行拒绝策略</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果在上面双重校验线程池状态后，线程池依然是RUNNING状态，或者remove()失败，则检测线程数量是否为0</span></span><br><span class="line"><span class="comment">         * 如果为0，则新起线程，此时线程不会有初始任务，并且占用maximumPoolSize个数</span></span><br><span class="line"><span class="comment">         * 为什么要这样做呢？因为此时只需保证至少存在一个线程可以执行后续任务即可</span></span><br><span class="line"><span class="comment">         * remove()失败的可能原因：刚好有线程执行完毕并且消耗了队列中的此任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第三阶段：</span></span><br><span class="line"><span class="comment">     * 如果线程池不是RUNNING状态，或者队列饱和，则尝试新起线程执行任务，并占用maximumPoolSize个数</span></span><br><span class="line"><span class="comment">     * 如果此时新起线程仍然失败，则执行拒绝策略</span></span><br><span class="line"><span class="comment">     * 新起线程仍然失败的可能原因：</span></span><br><span class="line"><span class="comment">     *     1.线程池已经shutdown了</span></span><br><span class="line"><span class="comment">     *     2.线程数量 &gt; maximumPoolSize </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行流程图："><a href="#执行流程图：" class="headerlink" title="执行流程图："></a>执行流程图：</h3><img src="http://kk.itblogs.club/static/images/并发/excute()方法-2.png-original_wm"><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>execute()方法基本都是在对【线程数量】和【线程池状态】这两个要素进行管控，然后根据不同的管控结果进行addWorker()或者reject()操作，真正的添加线程并启动任务是在addWorker()中做的。所以，addWorker()方法是我们接下来要重点研究的。</p><h2 id="添加线程：addWorker"><a href="#添加线程：addWorker" class="headerlink" title="添加线程：addWorker()"></a>添加线程：addWorker()</h2><p>来看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 外层循环，主要职责是从线程池状态上把关</span></span><br><span class="line"><span class="comment">     * retry是一个标记，相当于goto的思想</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 判断线程池状态的代码，这段代码反过来理解会轻松很多</span></span><br><span class="line"><span class="comment">         * 首先，上面讲到的线程池状态一共四个：RUNNING=-1，SHUTDOWN=0，STOP=1，TIDYING=2，TERMINATED=3</span></span><br><span class="line"><span class="comment">         * 数值越大，就越接近死亡状态</span></span><br><span class="line"><span class="comment">         * 解析出来就是 A &amp;&amp; B 都满足的时候，返回false，可以理解从【不可添加线程】状态。</span></span><br><span class="line"><span class="comment">         * 反过来就是 !A || !B，只要是其中任意一种满足，就是【可添加线程】状态</span></span><br><span class="line"><span class="comment">         * !A：只有一个状态，那就是RUNNING，只要是这个状态，就【可添加线程】</span></span><br><span class="line"><span class="comment">         * !B：rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty()，什么场景呢？就是线程池</span></span><br><span class="line"><span class="comment">         *状态虽然为SHUTDOWN，但是没有初始任务，单纯为了起一个线程，为的就是执行队列中残存的任务。</span></span><br><span class="line"><span class="comment">         * 只要满足这几个条件，也【可添加线程】</span></span><br><span class="line"><span class="comment">         * 其他任何情况，都是直接返回false，【不可添加线程】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 内层循环，主要职责是从线程数量把关，并且【线程数量+1】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * A || B，满足其中任意一种，就返回false，就是【不可添加线程】状态。</span></span><br><span class="line"><span class="comment">             * A：wc &gt;= CAPACITY，线程数量 &gt; 线程数量统计容量上限，都爆表了自然【不可添加线程】</span></span><br><span class="line"><span class="comment">             * B：wc &gt;= (core ? corePoolSize : maximumPoolSize)，线程数量的【临界值】，</span></span><br><span class="line"><span class="comment">             * 是corePoolSize或者maximumPoolSize，取决于core这个参数，上面有讲到过。如果超出</span></span><br><span class="line"><span class="comment">             * 这个【临界值】，此次添加线程也是返回false，就是【不可添加线程】</span></span><br><span class="line"><span class="comment">             * 总结来说就是，不爆表，也不超出临界值，就【可添加线程】</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * CAS操作【线程数量+1】，成功则跳出外层循环</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 失败则刷新ctl</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 然后判断线程池状态是否发生了变化</span></span><br><span class="line"><span class="comment">             * 如果发生了变化，则继续外层循环</span></span><br><span class="line"><span class="comment">             * 如果没有发生变化，则继续内层循环，执行CAS操作【线程数量+1】（CAS操作失败，</span></span><br><span class="line"><span class="comment">             * 是因为workerCount发生改变，所以要继续判断内层循环）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程成功启动标志</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 添加worker线程成功标志</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Worker本身就是Runnable，目前大体只要知道会用ThreadFactory创建一个线程，</span></span><br><span class="line"><span class="comment">         * 然后赋予worker的thread成员变量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 获取线程池锁，并且上锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 对应线程池状态的双重检查，需要满足一下两点：</span></span><br><span class="line"><span class="comment">                 * 1.rs = RUNNING</span></span><br><span class="line"><span class="comment">                 * 2.rs == SHUTDOWN &amp;&amp; 没有需要新接收的任务</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 检查线程是否已经被start过，确保每个线程只能start一次</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 将worker添加进workers</span></span><br><span class="line"><span class="comment">                     * workers本身是HashSet，非线程安全，所以要上锁操作</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 刷新历史最大线程个数</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 更新标志</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 线程池解锁</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 在worker成功添加进workers后，线程启动并更新标志</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 上面的很多因素都会导致addWorker失败，此时需要确保执行失败后的处理措施</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数解析："><a href="#参数解析：" class="headerlink" title="参数解析："></a>参数解析：</h3><ol><li>第一个参数firstTask：表示新起线程并需要执行的初始任务，可以为空</li><li>第二个参数core：如果为true则表示占用corePoolSize个数，也就是线程数量会和corePoolSize进行比较，如果为false则表示占用maximumPoolSize个数，也就是线程数量会和maximumPoolSize进行比较。</li></ol><p>所以不知道大家自己有没有思考过，线程本身会区分<strong>核心线程</strong>和<strong>非核心线程</strong>吗？如果你有过类似疑惑，那到这里应该有了答案。新起线程的时候，通过core参数控制，如果为true，说明还在第一阶段，如果为false，说明已经进入第二或者第三阶段。所以，添加的线程本身是无区别的，只不过因为core参数的不同，线程数量所比较的【临界值】不同而已。</p><h3 id="四种传参方式的使用场景："><a href="#四种传参方式的使用场景：" class="headerlink" title="四种传参方式的使用场景："></a>四种传参方式的使用场景：</h3><p>在execute()方法中用到了前3种，最后一种其实也很重要，它可以帮助预加载全部的核心线程池，我们来看一下：</p><ol><li>addWorker(command, true)：corePoolSize未满，此时就是在<strong>接收任务并新起线程执行它</strong>，所以在方法里面，线程数量会跟corePoolSize这个临界值比较</li><li>addWorker(command, false)：队列已饱和，此时也是在<strong>接收任务并新起线程执行它</strong>，但是不同的它尝试将线程扩容至maximumPoolSize，所以线程数量会跟corePoolSize这个临界值比较</li><li>addWorker(null, false)：此时是在做一种<strong>保护措施</strong>，新起一个线程但并不会给它分配初始任务，只是确保至少有一个线程消费队列中的任务。它的场景很可能是调用了shutdown()，这时候不会接受新任务，但队列中的任务依然会得到执行</li><li>addWorker(null, true)：它其实是在<strong>预启动核心线程池</strong>，这个方法新起的线程都没有初始任务，并且都占用corePoolSize个数，这些线程的职责就是等待从队列中获取任务并执行。实际使用中就是调用prestartAllCoreThreads()方法，这样就可以预先启动corePoolSize个线程，随时待命。</li></ol><h3 id="执行流程图：-1"><a href="#执行流程图：-1" class="headerlink" title="执行流程图："></a>执行流程图：</h3><img src="http://kk.itblogs.club/static/images/并发/addWorker()方法-2.png-original_wm"><h3 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h3><p>addWorker()总体来说就是在<strong>添加并启动线程</strong>，只不过它会围绕【线程数量】和【线程池状态】做很多校验，以确保是【可添加线程】状态才会真正的添加线程。在设计上值得注意的是，对HashSet这个非线程安全类的操作是使用了重入锁的，并且只对最小最必要的代码块上锁，很大程度上减轻了并发时对锁的竞争。</p><p>接下来我们看看对线程的封装——Worker，Worker的设计也有很多的巧妙之处。</p><h2 id="内部类：Worker"><a href="#内部类：Worker" class="headerlink" title="内部类：Worker"></a>内部类：Worker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Worker实现了Runnable，所以其本身就是任务，并且Worker继承了AQS，所以其本身就是锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// state初始赋值为-1，控制线程在启动后才能中断</span></span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 将worker自己作为参数通过ThreadFactory创建线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 真正的执行任务了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 重写AQS的isHeldExclusively()</span></span><br><span class="line"><span class="comment">     * 0代表【未锁定】状态</span></span><br><span class="line"><span class="comment">     * 1代表【锁定】状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * 重写AQS的tryAcquire()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 可以看到，这边每次都是用CAS操作，将状态从0-&gt;1，而不是递增，其实这已代表这是个【非重入锁】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 设置当前线程为锁的owner，其实就是当前线程获取到锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试释放锁</span></span><br><span class="line"><span class="comment">     * 重写AQS的tryRelease()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 释放锁，并且将锁状态设置为0（对比一下，锁在最开始的初始化状态为-1）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 以下四个public方法都是对AQS中方法的封装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 顾名思义，只有启动后的线程才能被中断</span></span><br><span class="line"><span class="comment">     * shutdownNow()方法最终会调用到该方法，因为shutdownNow不论你线程是否在运行，都会立即中断线程，</span></span><br><span class="line"><span class="comment">     *  所以该方法中的中断不需要获取worker锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 可以看到state的状态只要求&gt;0，所以在线程执行任务期间是可以中断的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker作为Runnable的作用"><a href="#Worker作为Runnable的作用" class="headerlink" title="Worker作为Runnable的作用"></a>Worker作为Runnable的作用</h3><ol><li>Worker实现了Runnable接口，所以Worker本身就是任务。可以看Worker的构造函数，它将接收的任务赋值给firstTask成员变量，然后将自己作为参数传递给ThreadFactory线程工厂，这样创建出线程再赋值给thread变量。</li><li>继续看Worker的run()方法，很简单，就runWorker(this)一行代码，将自身作为参数传递。所以thread.start()启动线程后，执行的任务就是firstTask中的run()，这一点可以在接下来对runWorker()方法的讲解中得到验证。</li></ol><h3 id="Worker作为AQS的作用"><a href="#Worker作为AQS的作用" class="headerlink" title="Worker作为AQS的作用"></a>Worker作为AQS的作用</h3><p>我们一步步分析：</p><ol><li>Worker继承了AbstractQueuedSynchronizer（AQS——队列同步器），AQS是java中用来构建锁和其他并发组件的基础框架，它基于模板模式实现，其中没有任何abstract抽象方法，而是在需要子类实现的方法中都直接抛出UnsupportedOperationException异常。AQS有几个非常重要的成员变量，其中很重要的一个就是state，state代表的是锁的获取情况，对于state的操作都是CAS操作。本篇文章不会详细解释AQS，有不清楚的大家可以自行查阅相关资料。</li><li>在Worker继承AQS时，它没有重写tryAcquireShared()和tryReleaseShared()方法，只是重写了tryAcquire()和tryRelease()方法，所以它是一个简单的<em>独占锁</em>。其实最重要的是它实现了<strong>非重入锁</strong>功能，大家可以看tryAcquire()方法中的注释。所以Worker通过继承AQS，就简化了线程在执行任务时对于锁的获取和释放，并且通过锁的获取状态控制线程中断。</li></ol><h3 id="非重入锁设计必要性"><a href="#非重入锁设计必要性" class="headerlink" title="非重入锁设计必要性"></a>非重入锁设计必要性</h3><p>tryAcquire()方法是获取worker锁的方法，它被tryLock()方法封装，所以我们看看谁调用了tryLock()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该方法主要就是中断空闲线程，何为空闲线程，就是不在执行任务的线程，反应到worker锁上就是</span></span><br><span class="line"><span class="comment"> *  没有获取到锁的线程，即state=0的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 获取worker锁，然后中断线程</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interruptIdleWorkers(boolean onlyOne)是ThreadPoolExecutor中封装的方法，只在这一处调用到了tryLock()，在ThreadPoolExecutor中，一共有以下方法调用了interruptIdleWorkers()：</p><ul><li>setCorePoolSize()</li><li>setMaximumPoolSize()</li><li>setKeppAliveTime()</li><li>allowCoreThreadTimeOut()</li><li>shutdown()</li></ul><p>此次对于非重入锁的必要性的分析，我们只以setCorePoolSize()为例，因为其他方法都与其类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 【核心线程个数】&gt;【当前线程个数】时，会尝试中断空闲线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We don't really know how many new threads are "needed".</span></span><br><span class="line">        <span class="comment">// As a heuristic, prestart enough new workers (up to new</span></span><br><span class="line">        <span class="comment">// core size) to handle the current number of tasks in</span></span><br><span class="line">        <span class="comment">// queue, but stop if queue becomes empty while doing so.</span></span><br><span class="line">        <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setCorePoolSize()方法主要是重新设置线程池的核心线程个数的，假如重新设置的【核心线程个数】&gt;【当前线程个数】，那么就需要中断那些空闲线程。</p><p>那么何为空闲线程呢？线程在执行任务时，都会通过w.tryLock()获取worker锁，所以说获取到锁的线程就是工作中的线程，未获取到锁的线程就是空闲线程，这一点也可以在接下来对runWorker()方法的解析中得到验证。</p><p>反过来想，假如worker是可重入锁，那工作中的线程即使获取到worker锁也会被中断，因为该锁可重入，这样就达不到【只中断空闲线程】的目的。这也是shutdownNow()方法不在上面队列中的原因，shutdownNow()的调用会中断你所有线程，无论线程是否正在工作，所以shutdownNow()对线程的中断不需要获取worker锁，这一点我们也在上面的interruptIfStarted()中也看到了。</p><p><strong>这里强调一点，ThreadPoolExecutor有个成员变量mainLock，它是ReentrantLock重入锁，大家千万不要跟这里的worker锁搞混淆，它们的作用不一样。mainLock是线程池锁，在ThreadPoolExecutor的很多方法中都有用到，包括上面讲到的execute()和addWorker()，它主要是控制外部线程对线程池对象的安全调用。而worker锁主要是在对线程池内部线程做管理，控制它们的中断。</strong></p><p>worker非重入锁的设计对于线程池中线程的中断控制可以做如下总结：</p><ul><li>worker对象刚new出来，锁的状态是state=-1，所以无论是interruptIfStarted()还是interruptIdleWorkers()，都无法中断线程。</li><li>对于setCorePoolSize()，setMaximumPoolSize()，setKeppAliveTime()，allowCoreThreadTimeOut()和shutdown()，它们最终会调用interruptIdleWorkers()，非重入锁的设计使得他们可以做到【只中断空闲线程】。</li><li>对于shutdownNow()，它最终会调用interruptIfStarted()，该方法不需要获取worker锁，所以它可以做到【立即中断所有线程】</li></ul><p>我们继续线程池整个流程的分析，Worker的run()方法中调用了runWorker(this)，我们来看看在这里面做了什么。</p><h2 id="执行任务：runWorker"><a href="#执行任务：runWorker" class="headerlink" title="执行任务：runWorker()"></a>执行任务：runWorker()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 该方法最终会调用worker的tryRelease()，它会将worker的state设置为0，这样就具备了被中断的初始条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 该值用于记录代码是否突然性完成，其实很好理解，它就是用来标志代码是否发生异常</span></span><br><span class="line"><span class="comment">     * 它的值会影响在最后处理worker的退出时，需不需要新起worker来替换此时的这个worker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 获取worker锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 自定义场景</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 自定义场景</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 任务置为空，worker完成任务数+1，worker锁解锁</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 只有从获取worker锁到释放worker锁整个期间，都没有出现异常，这个值才为false，因为只要有异常，</span></span><br><span class="line"><span class="comment">         *  最后都会直接到下面的finally中</span></span><br><span class="line"><span class="comment">         * false：代表整个过程没有异常</span></span><br><span class="line"><span class="comment">         * true：代表过程中出现了异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 处理worker的退出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了runWorker()的线程才算真正启动，并且一个线程只启动这么一次。一个线程的诞生，或许为了执行新任务，或许为了执行队列中的任务，但无论如何，调用了runWorker()后，等待这个线程的要么是执行任务然后阻塞在getTask()上，如此往复，要么就是灭亡。</p><h3 id="执行总结："><a href="#执行总结：" class="headerlink" title="执行总结："></a>执行总结：</h3><p>整个runWorker()的代码读起来很顺畅，三个try()三个finally()，都有各自的作用，总结一下：</p><ol><li>worker锁先释放，这样state会被设置成0，此时就具备了线程被中断的初始条件了</li><li>firstTask不为空，或者getTask()不为空，就会进入到执行task的run()方法的</li><li>执行任务之前，会先获取worker锁</li><li>开始执行task.run()，在前后会有自定义业务场景的执行，beforeExecute(wt, task)和afterExecute(task, thrown)</li><li>然后会释放worker锁</li><li>2-5的过程其实都在整个while循环中，所以就分7-8两种情况</li><li>假如任务执行过程中有任何异常，worker线程都会终止，processWorkerExit()会处理worker的退出流程，下面会有对processWorkerExit()方法的讲解</li><li>假如无任何异常，worker可能会在getTask()上阻塞，一直等取出任务，或者getTask()超时，超时就会返回null，这样就会结束while循环，也就意味着worker线程进入退出流程。下面就会进行getTask()的讲解。</li></ol><h2 id="获取任务：getTask"><a href="#获取任务：getTask" class="headerlink" title="获取任务：getTask()"></a>获取任务：getTask()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 对于线程池状态的判断，满足其一就直接返回null</span></span><br><span class="line"><span class="comment">         * 1.线程池状态 &gt; SHUTDOWN会返回null</span></span><br><span class="line"><span class="comment">         * 2.或者线程池状态 = SHUTDOWN的情况下，队列为空，也会直接返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 线程过期是否生效，满足其一即可</span></span><br><span class="line"><span class="comment">         * allowCoreThreadTimeOut = true 或者 当前线程数量 &gt; 核心线程池数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 对于线程过期并超时的判断：</span></span><br><span class="line"><span class="comment">         * 意思是说，只要队列是空或者线程数不止一个，那么线程超时应该立马得到反馈</span></span><br><span class="line"><span class="comment">         * 反馈的结果就是线程数减一并返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 会根据是否允许线程生效，来调用队列的不同方法</span></span><br><span class="line"><span class="comment">             * 1.生效：调用poll()，poll会阻塞keepAliveTime时长，超时后还没有获取到任务，</span></span><br><span class="line"><span class="comment">             *  就会返回null，之后timedOut设置为true，会在下次循环中因线程超时退出</span></span><br><span class="line"><span class="comment">             * 2.不生效：调用take()，take在队列中没有任务时会一直阻塞</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 线程如果被中断，会重新开始整个循环</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行流程图：-2"><a href="#执行流程图：-2" class="headerlink" title="执行流程图："></a>执行流程图：</h3><img src="http://kk.itblogs.club/static/images/并发/getTask()方法-2.png-original_wm"><h3 id="执行总结：-1"><a href="#执行总结：-1" class="headerlink" title="执行总结："></a>执行总结：</h3><ol><li><p>获取ctl</p></li><li><p>进行线程池状态的判断，判断规则：</p><ul><li>线程池状态为SHUTDOWN，并且队列为空，则【线程数-1】然后返回null</li><li>或者线程池状态&gt;SHUTDOWN，也同样可以【线程数-1】然后返回null</li></ul><p>这是很有必要的，SHUTDOWN状态是可以继续执行队列中的任务的，如果&gt;SHUTDOWN了，那么方法肯定要尽快返回。</p></li><li><p>是否允许线程过期生效，判断规则：</p><ul><li>如果设置过了allowCoreThreadTimeOut=true，那么timed=true，即线程过期生效</li><li>如果当前线程数 &gt; 核心线程数，那么也生效</li></ul></li><li><p>线程是否超时，如果满足，则CAS【线程数-1】并返回null，如若CAS操作是吧，则重新开始循环，判断规则：</p><ul><li>线程数 &gt; maximumPoolSize或者线程过期超时</li><li>同时还有满足，线程数 &gt; 1或者队列为空</li></ul></li><li><p>会根据timed值来调用队列不同的任务获取方法：</p><ul><li>true：调用poll()，poll会阻塞keepAliveTime时长，超时后还没有获取到任务，就会返回null，之后timedOut设置为true，会在下次循环中因线程超时退出</li><li>false：调用take()，该方法会一直阻塞直到获取任务</li></ul></li><li><p>获取任务的整个过程，如若线程被中断，会重置timedOut = false，然后重新整个循环</p></li></ol><h2 id="线程退出：processWorkerExit"><a href="#线程退出：processWorkerExit" class="headerlink" title="线程退出：processWorkerExit()"></a>线程退出：processWorkerExit()</h2><p>在讲runWorker()方法的时候有说过，worker会因为执行异常或者getTask()超时而进入worker的退出流程，下面来看看这个退出流程做了什么，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果是runWorker()中发生异常，这边就要【线程数-1】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 将该worker处理的任务总数计入到线程池处理的任务总数中去，</span></span><br><span class="line"><span class="comment">         *  然后从集合中移除该worker（代表该worker的终结）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这是一种【尝试终止线程池】的操作</span></span><br><span class="line"><span class="comment">     * 在整个ThreadPoolExecutor中，有好几个方法都有调用到它，其实它包含一种含义，</span></span><br><span class="line"><span class="comment">     *  就是对线程池有趋于“死亡”操作的方法都会【尝试终止线程池】，比如shutdown()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 下面都在讨论是否需要新起worker来代替该worker</span></span><br><span class="line"><span class="comment">     * 一切的前提是线程池的状态 &lt; STOP，即RUNNING或者SHUTDOWN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行总结：-2"><a href="#执行总结：-2" class="headerlink" title="执行总结："></a>执行总结：</h3><ol><li>如果是runWorker()中发生异常，需要执行【线程数-1】操作</li><li>线程池上锁</li><li>将worker处理过的任务计入到线程池处理的任务总数中去，然后从集合中移除该worker（代表该worker的终结）</li><li>tryTerminate()是一种【尝试终止线程池】的操作，在整个ThreadPoolExecutor中，有好几个方法都有调用到它，它的含义就是，任何对线程池有趋于“死亡”操作的方法都会【尝试终止线程池】，比如shutdown()</li><li>判断是否需要新起worker来代替该worker，判断逻辑大体为：<ul><li>首先必须满足线程池的状态 &lt; STOP，即RUNNING或者SHUTDOWN</li><li>如果是runWorker()中发生异常，就addWorker</li><li>如果runWorker()中没有发生异常，但是判断出“目前的线程数量偏少”了，就addWorker。“目前的线程数量偏少“的判断是很有意思的，它的核心思想就是【维护核心线程池】或者【队列不空，至少维护存在一个线程】</li></ul></li></ol><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>本篇文章主要是对线程池原理的剖析，由于篇幅的原因，对于Executors静态工厂提供的几种创建线程池的方法并未提及。然后，对于线程池中<strong>如何终止线程池</strong>这一话题，也只在“非重入锁设计必要性”一节中稍有讲到，这一部分内容其实很有必要单独拎出来进行讲解，里面有很多Doug Lea大神的思想精华。有机会的话后续会出文章对它们单独讲解，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;说明一下，本文的全部分析基于&lt;strong&gt;JDK1.8&lt;/strong&gt;，并且文章较长，需要一定的耐心。&lt;/p&gt;
&lt;p&gt;让我们开始，首先来看本次所讲到的java线程池相关API的继承图：&lt;/p&gt;
&lt;img src=&quot;http://kk.itblogs.club/static/images/并发/线程池继承关系.jpg-original_wm&quot;&gt;

&lt;h2 id=&quot;Executor&quot;&gt;&lt;a href=&quot;#Executor&quot; class=&quot;headerlink&quot; title=&quot;Executor&quot;&gt;&lt;/a&gt;Executor&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Executor&lt;/strong&gt;作为顶级接口，只有一个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable command)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;execute()方法可能会在新的线程中执行，也有可能会在线程池中的某个线程中执行，也有可能直接在调用者线程中执行，这一切都依赖于Executor的具体实现。Executor其实可以理解成一个“任务管理器”，比起你直接创建Thread然后执行任务，它会替你完成线程的创建以及任务的执行，乃至线程的回收等等，当然这一切都依赖于Executor的具体实现。&lt;/p&gt;
&lt;h2 id=&quot;ExecutorService&quot;&gt;&lt;a href=&quot;#ExecutorService&quot; class=&quot;headerlink&quot; title=&quot;ExecutorService&quot;&gt;&lt;/a&gt;ExecutorService&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ExecutorService&lt;/strong&gt;接口继承了Executor，它是Executor接口重要的功能扩展，它抽象出了诸多方法，你大可把它当做真正的线程池接口，来看它的API截图：&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发" scheme="http://itblogs.club/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://itblogs.club/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>WeakReference讲解</title>
    <link href="http://itblogs.club/2019/10/12/WeakReference%E8%AE%B2%E8%A7%A3/"/>
    <id>http://itblogs.club/2019/10/12/WeakReference讲解/</id>
    <published>2019-10-12T08:18:13.000Z</published>
    <updated>2019-10-15T06:53:54.033Z</updated>
    
    <content type="html"><![CDATA[<p>还没写，哈哈，敬请期待吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还没写，哈哈，敬请期待吧！&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码解析</title>
    <link href="http://itblogs.club/2019/10/11/ThreadLocal%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://itblogs.club/2019/10/11/ThreadLocal原理解析/</id>
    <published>2019-10-11T08:48:12.000Z</published>
    <updated>2019-10-15T08:30:33.393Z</updated>
    
    <content type="html"><![CDATA[<p>我在之前的文章中已经介绍过ThreadLocal的使用场景，这次不会再过多讲解，如果没有用过或者对它的用法还不是特别了解的朋友，欢迎访问这篇文章——<a href="[https://itblogs.club/2019/09/29/%E4%BD%A0%E8%BF%98%E5%9C%A8%E8%BF%99%E6%A0%B7%E7%94%A8ThreadLocal%EF%BC%9F/](https://itblogs.club/2019/09/29/你还在这样用ThreadLocal？/)">你还在这样用ThreadLocal？</a>。今天，继续ThreadLocal这个主题，从源码角度来分析它的原理。</p><p>ThreadLocal的API定义：</p><img src="http://kk.itblogs.club/static/images/并发/ThreadLocal_API定义.jpg-original"><ul><li>get()方法：获取当前线程保存的变量副本。</li><li>initialValue()方法：是一个<em>protected</em>方法，一般在声明ThreadLocal的时候重写，稍后会详细讲解它。</li><li>remove()方法：删除当前线程保存的变量副本。</li><li>set()方法：设置当前线程所需保存的变量副本值。</li><li>withInitial()方法：静态方法，它是重写initialValue()方法的另一种变体，是java1.8新特性<em>函数式接口</em>的应用，用lambda表达式可以让你的匿名内部类写法更加简洁，我会在后面讲解initialValue()方法的时候提到它。</li></ul><a id="more"></a><h1 id="从ThreadLocal的get-方法入手"><a href="#从ThreadLocal的get-方法入手" class="headerlink" title="从ThreadLocal的get()方法入手"></a>从ThreadLocal的get()方法入手</h1><p><strong>get()</strong>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();<span class="comment">// 1</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);<span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;<span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();<span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从get()方法的代码注释可以看到，它会返回当前线程的变量副本对象，如果没有获取到，最终返回的是initialValue()方法初始化的值，详细分析代码逻辑大概可以描述为：</p><ol><li>获取当前线程<strong>Thread</strong>对象。</li><li>获取<font color="red">当前线程对象</font>中的<strong>ThreadLocalMap</strong>对象，这比较关键，因为你要知道map对象是根据当前线程获取的，ThreadLocalMap你可以类比成类集框架中的Map，它的主要功能是以键值对的形式来存储变量副本，把它看作一个“容器”就好了，接下来我会详细讲它的。</li><li>如果成功获取到ThreadLocalMap对象，就根据<font color="red">当前ThreadLocal对象</font>尝试获取<strong>ThreadLocalMap.Entry</strong>对象，这也很关键，entry就是&lt;key,value&gt;中我们要获取的value，key呢？就是你调用get()方法时候的ThreadLocal对象。这样设计的好处是你可以申明多个ThreadLocal，每个获取自己保存的变量副本，互不干扰。如果这一点让你困惑，文章的后面我会画图讲解。</li><li>如果Entry成功获取，就返回它的value成员变量，因为变量副本就保存在value属性中。</li><li>如果第3步没有成功获取，就初始化变量副本。</li></ol><p>总得来说get()方法贯穿全局，第2，3，5步是其中的关键，搞懂了它们，你就理解了ThreadLocal。</p><h2 id="如何获取ThreadLocalMap对象？"><a href="#如何获取ThreadLocalMap对象？" class="headerlink" title="如何获取ThreadLocalMap对象？"></a>如何获取ThreadLocalMap对象？</h2><p>我们继续跟进getMap()看看</p><p><strong>getMap()</strong>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看吧，很简单是吧，从1处我们大概可以猜到Thread类中有个ThreadLocalMap类型的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>每个线程都会有一个ThreadLocalMap类型的成员变量，getMap()方法中以当前线程作为参数获取。ThreadLocalMap是什么呢？</p><img src="http://kk.itblogs.club/static/images/并发/ThreadLocalMap类定义.jpg-original"><p>如上图，我们看到ThreadLocalMap是ThreadLocal的内部类，Entry又是ThreadLocalMap的内部类，并且Entry继承了java中的WeakReference弱引用类，有个value成员变量。这里如果不了解请不用纠结，你只要知道Entry对于它的key值是一个弱引用，不这么做线程运行时间过长会有内存泄露的风险，如果感兴趣可以阅读我的<a href="https://itblogs.club/2019/10/12/WeakReference%E8%AE%B2%E8%A7%A3/">WeakReference讲解</a>。我们继续，来看Entry的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略ThreadLocalMap中的其他代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中，我们需要保存的变量副本赋值给value变量，很简单。</p><h2 id="如何获取保存的变量副本？"><a href="#如何获取保存的变量副本？" class="headerlink" title="如何获取保存的变量副本？"></a>如何获取保存的变量副本？</h2><p>我们继续跟进ThreadLocalMap的<strong>getEntry()</strong>方法看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ThreadLocalMap的&lt;key,value&gt;怎么体现，就是利用当前的ThreadLocal对象的hash值作为脚标从ThreadLocalMap保存Entry[]中获取，所以可以简单理解ThreadLocal对象就是key嘛。</li><li>下面这一步我就大概说一下，因为它对于你理解ThreadLocal的整体流程不会造成影响。这一步逻辑是，如果发生key值错位，那么就会一直循环直到找出正确的Entry或者到数组末尾还没找到就返回null，如果因为弱引用的原因发生了GC，而导致存在了为null的key值，就会将对应位置的Entry从数组中擦除，有兴趣的可以跟进去看看。反正你可以理解为，获取不到Entry就返回null。</li></ol><p>到此为止，第2，3步骤我们都讲到了，也大致了解是怎么根据当前线程获取ThreadLocalMap的，而又是怎么根据当前ThreadLocal从ThreadLocalMap这个“容器”中获取Entry值的，获取到Entry后，它的value变量就是我们保存的变量副本。但是如果上面的步骤最终<strong>获取不到Entry值或者说我们压根儿就没有对变量副本进行过初始化怎么办？</strong></p><h2 id="如何对变量副本进行初始化？"><a href="#如何对变量副本进行初始化？" class="headerlink" title="如何对变量副本进行初始化？"></a>如何对变量副本进行初始化？</h2><p>那我们看get()方法中的第5步，<strong>setInitialValue()</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();<span class="comment">// 1</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先初始化一个值，赋值给value。</li><li>如果当前线程中ThreadLocalMap类型的成员变量还没有初始化，就创建，然后以threadLocal(就是this)为key，变量副本的初始值为value保存起来。保存过程代码不复杂，就不进去看了。</li></ol><p><strong>initialValue()</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current thread's "initial value" for this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  This method will be invoked the first</span></span><br><span class="line"><span class="comment"> * time a thread accesses the variable with the &#123;<span class="doctag">@link</span> #get&#125;</span></span><br><span class="line"><span class="comment"> * method, unless the thread previously invoked the &#123;<span class="doctag">@link</span> #set&#125;</span></span><br><span class="line"><span class="comment"> * method, in which case the &#123;<span class="doctag">@code</span> initialValue&#125; method will not</span></span><br><span class="line"><span class="comment"> * be invoked for the thread.  Normally, this method is invoked at</span></span><br><span class="line"><span class="comment"> * most once per thread, but it may be invoked again in case of</span></span><br><span class="line"><span class="comment"> * subsequent invocations of &#123;<span class="doctag">@link</span> #remove&#125; followed by &#123;<span class="doctag">@link</span> #get&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation simply returns &#123;<span class="doctag">@code</span> null&#125;; if the</span></span><br><span class="line"><span class="comment"> * programmer desires thread-local variables to have an initial</span></span><br><span class="line"><span class="comment"> * value other than &#123;<span class="doctag">@code</span> null&#125;, &#123;<span class="doctag">@code</span> ThreadLocal&#125; must be</span></span><br><span class="line"><span class="comment"> * subclassed, and this method overridden.  Typically, an</span></span><br><span class="line"><span class="comment"> * anonymous inner class will be used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value for this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很短，注释很长，这里翻译一下大概就是：返回当前线程的变量副本的初始值，该方法会在get()方法第一次被调用的时候调用，除非当前线程已经预先用set()方法设置过值了。通常来讲，一个线程只会调用一次该方法，但如果你调用remove()方法后还想用get()获取，该方法就会被再次调用。</p><p>嗯，跟我们开头介绍它的时候说的差不多，这个方法一般会在使用ThreadLocal的时候重写它，重写该方法的目的是为了让ThreadLocal知道怎么初始化变量副本，一般会在声明的时候这样用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种不推荐使用，因为你之后还需要先调用set()方法，不然get()方法得到null的副本值，有空指针风险</span></span><br><span class="line"><span class="comment">// private static ThreadLocal&lt;People&gt; threadLocal = new ThreadLocal&lt;People&gt;();</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;People&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;People&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> People <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这边的People就是我自己想要处理的变量副本类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> People(<span class="string">"kkkboy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的匿名内部类写法稍微繁琐一点，java 8 可以有新特性使用，我们看看<strong>withInitial()</strong>静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line">        SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">            <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，SuppliedThreadLocal是ThreadLocal的内部类，并且在里面重写了initialValue()方法，所以通过lambda表达式，可以将ThreadLocal的使用写法大大简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;People&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> People(<span class="string">"kkkboy"</span>));</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal工作流程总结"><a href="#ThreadLocal工作流程总结" class="headerlink" title="ThreadLocal工作流程总结"></a>ThreadLocal工作流程总结</h2><p>到此为止，我们通过从ThreadLocal的get()方法入手，已经讲了ThreadLocal的大部分内容，这边总结一下它的工作流程：</p><ol><li>首先在使用ThreadLocal的时候，一般会重写initialValue()方法。</li><li>然后，当你第一次使用get()方法获取当前线程的变量副本的时候，因为获取不到，就会调用initialValue()给变量副本初始化值。</li><li>之后对get()的每一次调用，都会先获取当前线程中的ThreadLocalMap对象，该对象中以键值对的形式保存变量副本，其中key就是当前ThreadLocal对象，然后直接返回对应的value值。</li><li>set()方法一般是在你没有重写initialValue()的时候用到，因为如果这样做，在第一次调用get()的会返回null，存在空指针风险。</li><li>remove()方法可以让你手动擦除当前线程对应的变量副本值。</li></ol><h1 id="一些问题的讨论"><a href="#一些问题的讨论" class="headerlink" title="一些问题的讨论"></a>一些问题的讨论</h1><h2 id="为什么要以ThreadLocal为key？"><a href="#为什么要以ThreadLocal为key？" class="headerlink" title="为什么要以ThreadLocal为key？"></a>为什么要以ThreadLocal为key？</h2><p>你们有没有想过，从当前线程中获取了ThreadLocalMap之后，为什么还要以ThreadLocal对象为key才能获取到我们保存的变量副本。或者说，保存变量副本的“容器”，为什么要设计成&lt;key,value&gt;形式的键值对保存，为什么不直接获取变量副本呢？那是因为如果真的这么做，一个线程就只能保存一个变量副本，所以如果你需要在一个线程中保存多个变量副本时候就没办法了，比如像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Cat&gt; threadLocal_cat = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> Cat(<span class="string">"JiaFei"</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Dog&gt; threadLocal_dog = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> Dog(<span class="string">"JinMao"</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Mouse&gt; threadLocal_mouse = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> Mouse(<span class="string">"Mi"</span>));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你在每一个线程中都需要用到Cat、Dog和Mouse等等这些类型的对象，这种需求是很正常的，这种情况下，用键值对的形式保存的设计就很巧妙了。对于一个线程来说，每一个ThreadLocal对象都获取自己对应的那个变量副本，互不干扰。来看一下示意图：</p><img src="http://kk.itblogs.club/static/images/并发/ThreadLocal保存变量副本示意图.jpg-original_wm"><h2 id="对于remove-方法要注意什么？"><a href="#对于remove-方法要注意什么？" class="headerlink" title="对于remove()方法要注意什么？"></a>对于remove()方法要注意什么？</h2><p>remove()方法大部分时候都不需要你额外考虑对它的调用，因为一个线程执行完任务会被销毁。但如果你用<em>线程池</em>去设计一些功能的时候，要对remove()方法的调用格外重视，我们可以一起来看下这个示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String tag;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestTask</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (threadLocal.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程没有获取到变量副本，就设置副本值</span></span><br><span class="line">        threadLocal.set(tag);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out</span><br><span class="line">          .println(<span class="string">"当前线程名称："</span> + Thread.currentThread().getName() + </span><br><span class="line">              <span class="string">"，保存的变量副本值："</span> + threadLocal.get());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 尝试注释掉此代码再运行看看结果变化</span></span><br><span class="line">      threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExecutorTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Executor executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      executor.execute(<span class="keyword">new</span> TestTask(String.valueOf(i)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码并不复杂，大家只要注意上面remove()方法的使用，直接运行的结果和注释掉remove()方法的运行结果对比一下。</p><p>有remove()方法：</p><blockquote><p>当前线程名称：pool-1-thread-2，保存的变量副本值：1<br>当前线程名称：pool-1-thread-3，保存的变量副本值：2<br>当前线程名称：pool-1-thread-2，保存的变量副本值：3<br>当前线程名称：pool-1-thread-1，保存的变量副本值：0<br>当前线程名称：pool-1-thread-3，保存的变量副本值：4</p></blockquote><p>注释remove()方法：</p><blockquote><p>当前线程名称：pool-1-thread-1，保存的变量副本值：0<br>当前线程名称：pool-1-thread-3，保存的变量副本值：2<br>当前线程名称：pool-1-thread-2，保存的变量副本值：1<br>当前线程名称：pool-1-thread-3，保存的变量副本值：2<br>当前线程名称：pool-1-thread-1，保存的变量副本值：0</p></blockquote><p>可以看到，如果调用了remove()方法，每个线程获取的变量副本值不会重复，即使是复用线程的情况下。但注释掉remove()方法，在线程复用的时候，得到与之前一样的变量副本。因为此时线程复用，不会被销毁，所以变量副本也不会擦除，这样这个线程下次执行新任务的时候，就会获取上次的变量副本而不进行初始化，有可能这是你本意，但有可能不是。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在之前的文章中已经介绍过ThreadLocal的使用场景，这次不会再过多讲解，如果没有用过或者对它的用法还不是特别了解的朋友，欢迎访问这篇文章——&lt;a href=&quot;[https://itblogs.club/2019/09/29/%E4%BD%A0%E8%BF%98%E5%9C%A8%E8%BF%99%E6%A0%B7%E7%94%A8ThreadLocal%EF%BC%9F/](https://itblogs.club/2019/09/29/你还在这样用ThreadLocal？/)&quot;&gt;你还在这样用ThreadLocal？&lt;/a&gt;。今天，继续ThreadLocal这个主题，从源码角度来分析它的原理。&lt;/p&gt;
&lt;p&gt;ThreadLocal的API定义：&lt;/p&gt;
&lt;img src=&quot;http://kk.itblogs.club/static/images/并发/ThreadLocal_API定义.jpg-original&quot;&gt;

&lt;ul&gt;
&lt;li&gt;get()方法：获取当前线程保存的变量副本。&lt;/li&gt;
&lt;li&gt;initialValue()方法：是一个&lt;em&gt;protected&lt;/em&gt;方法，一般在声明ThreadLocal的时候重写，稍后会详细讲解它。&lt;/li&gt;
&lt;li&gt;remove()方法：删除当前线程保存的变量副本。&lt;/li&gt;
&lt;li&gt;set()方法：设置当前线程所需保存的变量副本值。&lt;/li&gt;
&lt;li&gt;withInitial()方法：静态方法，它是重写initialValue()方法的另一种变体，是java1.8新特性&lt;em&gt;函数式接口&lt;/em&gt;的应用，用lambda表达式可以让你的匿名内部类写法更加简洁，我会在后面讲解initialValue()方法的时候提到它。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="并发" scheme="http://itblogs.club/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://itblogs.club/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>认识Docker</title>
    <link href="http://itblogs.club/2019/10/05/%E8%AE%A4%E8%AF%86Docker/"/>
    <id>http://itblogs.club/2019/10/05/认识Docker/</id>
    <published>2019-10-05T08:58:29.000Z</published>
    <updated>2019-10-15T08:20:46.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们先来思考以下几个问题：</p><ol><li><p>假如我们现在只有一台物理主机，但是我们现在开发了两个应用程序A和B，并且他们各自依赖很多不同的组件，当然也有依赖相同的组件，但是这些相同组件的版本不一样，比如A基于Node.js的一个早期版本，而B基于Node.js的一个最新版本（只是打个比方，可能不准确，但类似情况确实可能存在）。这时候，我们的第一想法是不是用VirtualBox或者VMware这种虚拟化软件创建出几个虚拟机，分别部署A和B。</p></li><li><p>Ok，在我们的应用程序数量不多的情况下，我们完全可以接受上面的做法，就是给每个应用程序分配专用的虚拟机，这样每个应用程序就可以通过自己的操作系统实例来隔离它们的环境了。但现在由于微服务的细分，使得我们开发的应用程序的功能越来越细，数量越来越多，这时候如果不想浪费硬件资源，又想压低硬件成本，显然为每个应用程序分配一个虚拟机已经不现实了。</p></li><li><p>如果你是一个开发人员，你可能还会面临一个非常棘手的问题就是，你在自己开发环境上，测试应用程序是跑得通的，但一旦交给测试或者运维，让他们在自己的环境上运行时，就出现各种各样的bug。解决环境不一致的问题就变得越来越严峻了。</p></li></ol><a id="more"></a><p>在上述问题的背景下，基于Linux的进程隔离的容器技术应运而生，其中又以Docker最为出名，使用最为广泛。</p><p>在2010年，美国旧金山诞生出了一家叫“DotCloud”的创业公司，它们提供LXC有关的容器技术。LXC，就是Linux容器技术，并且他们将自己的产品命名为——Docker。</p><p>Docker的灵感来自于集装箱，非常形象，利用Docker打包的应用，就像一个个集装箱，它们拥有各自的环境，并且相互隔离，最重要的是，集装箱一个个都方方正正，可以最大程度的利用货轮的空间，也就相当于最大程度的利用硬件资源。所以Docker的官方图标就是一个可爱的鲸鱼加集装箱的图案。</p><img src="http://kk.itblogs.club/static/images/kubernetes/Docker.jpg-original0.75"><h1 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h1><p>容器技术其实已经出现很久，但是却随着Docker容器平台的出现而变得广为人知。Docker不仅简化了打包应用的流程，也简化了打包应用的库和依赖，甚至整个操作系统的文件系统都能被打包成一个简单的可移植的包，这个包可以在其他任何可运行Docker的机器上使用。</p><p>当你用Docker运行一个被打包的应用程序时，这个应用程序可以看见你捆绑的文件系统的内容，不管运行在开发机器还是生产机器上，即使两者是完全不同的操作系统。此时的应用程序不会关心它所在服务器上的任何东西，所以生产环境是否安装了你开发环境上必要的组件根本不需要关心。举例来说，你用红帽企业版Linux(RHEL)的文件打包了你的应用程序，不管在装有Fedora的开发机器上运行它，还是在装有Debian或者其他Linux发行版的服务器上运行它，应用程序都认为自己跑在RHEL中。此时想想，是不是无形之中已经解决了上面第三个问题。</p><p>Docker作为一个打包、分发和运行应用程序的平台，它允许将你的应用程序和所必须的环境打包在一起变成一个整体，这时就已经使传输这个包到一个中央仓库成为可能，然后在任何可以访问这个中央仓库的机器上都可以获取这个包然后执行，确实Docker就是这么做的。我们来看看Docker中最重要的三个概念：</p><ul><li>镜像——Docker镜像里包含了你打包的应用程序和其所依赖的环境。</li><li>仓库——仓库作为存放Docker镜像的地方，可以让不同的用户不同的机器共享这些镜像。镜像仓库可以使公开的，比如官方的DockerHub，也可以是个人或者公司搭建的私有仓库，这时可以限制部分人或部分机器可以访问，比如Harbor私有镜像仓库。</li><li>容器——Docker容器通常是一个Linux容器，它基于Docker镜像创建。一个运行中的容器就是一个运行在宿主机上的进程（不要把它复杂化，它就是一个普通的进程），它和所有该宿主机上的其他进程相互隔离。当然，这个进程拥有的计算资源也是受限的，一般只能访问和使用分配给它的资源，比如CPU和内存等等。</li></ul><p>Docker镜像的构建、分发以及运行的流程大概是这样的，开发人员首先构建一个镜像，然后把镜像推送到镜像仓库。此时，任何可以访问镜像仓库的人都可以拉取到该镜像，然后他们就把镜像拉取到任何可以运行Docker的机器并运行，Docker会基于镜像创建一个独立容器。大致流程可参考下图：</p><img src="http://kk.itblogs.club/static/images/kubernetes/构建、分发和运行Docker镜像.jpg-original_wm"><p>其实，在起初，Docker的诞生并没有引起行业的关注，而后不得已，DotCloud公司将其开源，自己养不起大家一起养嘛。开源之后的Docker人气迅速飙升，世界各地的开发者都参与进来，在开源后的一年里，几乎每个月都发布一个小版本，于是乎，在2014年6月份，Docker的1.0正式版本发布。</p><p>在容器技术之前，业界使用最多的其实是虚拟机，虚拟机技术的代表，是VMWare和OpenStack。但如今，即使是像谷歌、VMware和Amazon这样的大佬也都在构建相关服务为其提供支持。</p><p>归根结底，是什么让Docker发展如此迅速呢？其实答案也简单，因为它更<strong>轻</strong>，更<strong>快</strong>。</p><h1 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h1><p>容器可以允许你在一台主机上运行多个应用程序，不仅提供它们各自的运行环境，而且让它们相互隔离，和虚拟机很相似，但是容器的开销可比虚拟机要小的多得多。</p><p>容器里运行的进程实际上是运行在宿主机的操作系统上的，就像宿主机上的其它进程一样。但是虚拟机不一样，虚拟机需要依靠虚拟化软件（比如前面提到的VMware）独立出自己的操作系统，所以虚拟机跑的进程都是在自己操作系统之上的，跟宿主机的操作系统没有直接关联。</p><p>虽然容器中的进程是运行在宿主机操作系统上的，但是每个容器的进程相互之间依然是隔离的，所以对于容器本身而言，里面的应用程序，感觉就像是自己运行在一个独立的主机和操作系统上一样，它们对外界是无感知的。</p><h2 id="更“轻”"><a href="#更“轻”" class="headerlink" title="更“轻”"></a>更“轻”</h2><img src="http://kk.itblogs.club/static/images/kubernetes/虚拟机和容器隔离级别对比-虚拟机.png-original_wm"><p>可以看到，每个虚拟机都需要运行自己的一组系统进程（你可以简单理解为操作系统程序），这样就产生了除了应用程序进程之外的额外计算资源的消耗。如果你用VMware等软件创建过虚拟机，你肯定知道光是操作系统的镜像就很大有好几个G，创建好的虚拟机，光系统文件就占很大磁盘空间，系统进程也很消耗计算资源。</p><img src="http://kk.itblogs.club/static/images/kubernetes/虚拟机和容器隔离级别对比-Docker.png-original_wm"><p>但对于容器来说，一个容器仅仅是运行在宿主机上的被隔离的单个进程，它仅消耗应用容器所消耗的资源，不会有其他进程的开销。</p><p>正因为虚拟机的额外开销，所以很多时候没有足够的计算资源为每个应用程序开一个专门的虚拟机，最终会导致多个应用程序部署在一个虚拟机上。当使用容器时，可以让每个应用程序有一个容器，最终同一台裸机可以运行更多的应用程序（上图可能没有体现，但实际上确实如此）。所以，对比虚拟机，容器更<strong>轻</strong>。</p><h2 id="更“快”"><a href="#更“快”" class="headerlink" title="更“快”"></a>更“快”</h2><p>另外值得一提的是，对于虚拟机而言，运行在虚拟机里的应用程序，会执行虚拟机操作系统的系统调用，然后虚拟机内核会通过虚拟化管理程序来给宿主机上的物理CPU下达x86指令（其实存在两种类型的虚拟化管理程序。第一种不会使用宿主机OS，而另一种会）。对于Docker而言，Docker会在宿主机器的操作系统上创建Docker引擎，直接在宿主主机的操作系统上调用硬件资源下达指令，而不是虚拟化操作系统通过虚拟化管理程序来和硬件资源交流，所以操作速度快。可以参考下面表格的全方位对比：</p><table><thead><tr><th align="center">特性</th><th align="center">虚拟机</th><th align="center">容器</th></tr></thead><tbody><tr><td align="center">隔离级别</td><td align="center">操作系统级别</td><td align="center">进程级别</td></tr><tr><td align="center">隔离策略</td><td align="center">hypervisor</td><td align="center">Cgroups</td></tr><tr><td align="center">系统资源</td><td align="center">5~20%</td><td align="center">0~5%</td></tr><tr><td align="center">启动时间</td><td align="center">分钟级</td><td align="center">秒级</td></tr><tr><td align="center">镜像存储</td><td align="center">GB~TB</td><td align="center">KB~MB</td></tr><tr><td align="center">集群规模</td><td align="center">上百</td><td align="center">上万</td></tr><tr><td align="center">高可用策略</td><td align="center">备份、容灾、迁移</td><td align="center">弹性、负载、动态</td></tr></tbody></table><p>对于操作指令的下达，容器不需要像虚拟机一样“拐弯抹角”，这也大大提高了程序的执行效率，所以容器更<strong>快</strong>。</p><h1 id="Docker镜像分层存储"><a href="#Docker镜像分层存储" class="headerlink" title="Docker镜像分层存储"></a>Docker镜像分层存储</h1><p>同时，从上面示意图中我们还可以看到，不管是运行在虚拟机中还是容器中，都会出现多个应用程序共享同一个二进制和依赖库的情况，在虚拟机里，这是很显然的，它们使用同一个文件系统，那对于容器来讲，这种情况如何理解呢？不同的容器不是都有自己隔离的文件系统吗？什么情况下，不同的容器会共享同一个文件系统呢？</p><p>其实是因为在Docker的概念中，容器是由镜像生成的，而镜像又是采用分层存储的，不同的镜像很有可能包含完全相同的层。分层存储不仅使分发更加高效，也有助于减少镜像的存储空间，每一层仅被存储一次。自然而然，如果基于相同的基础层的镜像被创建成两个容器时，他们就能够读相同的文件，因为此时它们拥有相同的<strong>镜像层</strong>。</p><p>镜像层的文件系统是只读的，一个Docker镜像是由多个只读的镜像层组成的，在运行容器的时候，会在镜像层上面多加一层可写的<strong>容器层</strong>，对文件的修改都只存在于容器层。比如，当容器内进程想要修改镜像层的某个文件时，会把这个文件的拷贝在容器层创建，然后修改的只是存在于容器层的拷贝。</p><p>此时，另一个容器即使拥有相同的镜像层，也不会看到其他容器的文件修改，因为它们拥有各自的容器层，是互相隔离的。</p><img src="http://kk.itblogs.club/static/images/kubernetes/容器镜像分层存储.jpg-original_wm"><h1 id="容器隔离机制"><a href="#容器隔离机制" class="headerlink" title="容器隔离机制"></a>容器隔离机制</h1><p>你可能会好奇，如果多个进程运行在同一个操作系统上，那么容器到底是怎样隔离它们的。大概会用到两个机制，第一个是Linux<strong>命名空间</strong>，它使每个进程只看到它们自己的系统视图（文件、进程、网络接口和主机名等）；第二个是Linux<strong>控制组</strong>（cgroups），它限制了进程能使用的资源量（CPU、内存、网络带宽等）。</p><h2 id="用Linux命名空间隔离进程"><a href="#用Linux命名空间隔离进程" class="headerlink" title="用Linux命名空间隔离进程"></a>用Linux命名空间隔离进程</h2><p>默认情况下，每个Linux系统最初只有一个命名空间，所有系统资源（例如文件系统、用户ID、网络接口等）都属于这一个命名空间。但是你能创建额外的命名空间，以及在它们之间组织资源。对于一个进程，可以在其中一个命名空间中运行它，该进程只能看到同一命名空间下的资源。当然，会存在多种类型的多个命名空间，所以一个进程往往不只是属于一个命名空间，它会属于多种类型的多个命名空间。</p><p>存在以下类型的命名空间，Docker会在内核中使用它们，将它们结合起来创建出相互隔离的容器：</p><ul><li>Mount(MNT): 挂载视图，该命名空间主要为容器提供不同的文件系统结构。</li><li>Process ID(PID): 进程树视图，如果你运行过<em>ps aux</em>查看当前系统正在运行的进程，其中以“PID”命名的一栏就是进程ID。该命名空间主要为容器提供其能够查看与交互的进程范围。</li><li>Network(NET): 网络堆栈视图，该命名空间主要为容器提供自己独有的网络设备、IP地址和网络端口号等。</li><li>IPC: 该命名空间主要为容器中的进程提供进程间通信的隔离能力。</li><li>UTS: UTS代表UNIX分时系统，它允许某一进程识别系统身份（例如主机名称或者域名等）。该命名空间主要为容器提供不同于其它容器的主机名称和域名。</li><li>User ID(user): 用户与用户组视图，该命名空间允许各容器拥有不同的即<strong>用户ID</strong>与<strong>组ID</strong>视图区间，这样，对于同一用户来讲，在容器内和容器外拥有的权限时不一样的。</li></ul><h2 id="用控制组限制可用资源"><a href="#用控制组限制可用资源" class="headerlink" title="用控制组限制可用资源"></a>用控制组限制可用资源</h2><p>控制组（cgroups）属于Linux内核中的一项功能，用于对一组进程的资源使用量（包括CPU、内存、磁盘I/O以及网络等）进行隔离、排序与计数。这意味着cgroups能够确保Docker容器只使用其必需的资源——并在必要情况下设置其所能使用的资源上限。通过cgroups的限制，多个容器跑在同一台机器上就跟多个应用程序跑在多台机器上很类似了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文只是大概讲了Docker容器的背景与相关概念，关于Docker还有更多更好玩的内容，推荐大家购买相关书籍进行阅读。接下来我会写多篇文章对<strong>Kubernetes</strong>的概念以及各个组件进行详细介绍，来看看我们的“舵手”是怎样为我们一个个“集装箱”在微服务的大风大浪下保驾护航的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们先来思考以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;假如我们现在只有一台物理主机，但是我们现在开发了两个应用程序A和B，并且他们各自依赖很多不同的组件，当然也有依赖相同的组件，但是这些相同组件的版本不一样，比如A基于Node.js的一个早期版本，而B基于Node.js的一个最新版本（只是打个比方，可能不准确，但类似情况确实可能存在）。这时候，我们的第一想法是不是用VirtualBox或者VMware这种虚拟化软件创建出几个虚拟机，分别部署A和B。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ok，在我们的应用程序数量不多的情况下，我们完全可以接受上面的做法，就是给每个应用程序分配专用的虚拟机，这样每个应用程序就可以通过自己的操作系统实例来隔离它们的环境了。但现在由于微服务的细分，使得我们开发的应用程序的功能越来越细，数量越来越多，这时候如果不想浪费硬件资源，又想压低硬件成本，显然为每个应用程序分配一个虚拟机已经不现实了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你是一个开发人员，你可能还会面临一个非常棘手的问题就是，你在自己开发环境上，测试应用程序是跑得通的，但一旦交给测试或者运维，让他们在自己的环境上运行时，就出现各种各样的bug。解决环境不一致的问题就变得越来越严峻了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://itblogs.club/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://itblogs.club/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>你还在这样用ThreadLocal？</title>
    <link href="http://itblogs.club/2019/09/29/%E4%BD%A0%E8%BF%98%E5%9C%A8%E8%BF%99%E6%A0%B7%E7%94%A8ThreadLocal%EF%BC%9F/"/>
    <id>http://itblogs.club/2019/09/29/你还在这样用ThreadLocal？/</id>
    <published>2019-09-29T15:50:29.000Z</published>
    <updated>2019-10-15T07:04:16.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>因为看到有很多人，对ThreadLocal并没有充分的理解，从而出现了很多奇怪的问题，甚至可能在生产环境中出现致命错误。因为ThreadLocal在多线程中的特殊性，往往问题还很难定位到，今天，我就带大家一起来探讨一下ThreadLocal的正确用法。</p><h1 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h1><p>要理解 ThreadLocal，先来看看官方对它的解释：</p><p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p><a id="more"></a><p>大概翻译一下就是：</p><blockquote><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p></blockquote><p>总结一下重点：</p><ul><li>ThreadLocal 提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是当前这个线程私有的，这就是所谓的线程隔离。</li><li>如果要使用 ThreadLocal，通常定义为 private static 类型，在我看来最好是定义为 private static final 类型。</li></ul><h1 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h1><p>对 ThreadLocal理解了以后，我们一般会有这样的想法：</p><p>对同一个线程调用的多个方法中，共享了某一个变量，这个变量需要传递到多个方法中，这样传来传去太麻烦了，这时就可以采用 ThreadLocal 了。</p><h1 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h1><p>下面我们来看一个错误的用法。先创建一个用来作为共享变量的实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xttblog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略get和set</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Xttblog</span><span class="params">(String title, Long id, String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个线程 ThreadLocalTarget：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Xttblog blog = <span class="keyword">new</span> Xttblog(<span class="string">"ThreadLocal 会导致内存泄露？"</span>,<span class="number">1L</span>,<span class="string">"...."</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Xttblog&gt; local = <span class="keyword">new</span> ThreadLocal&lt;Xttblog&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocalTarget</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocalTarget.local.set(blog);</span><br><span class="line"> </span><br><span class="line">        ThreadLocalTarget.local.get().setTitle(<span class="string">"test"</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"更改后的名字："</span> +  ThreadLocalTarget.local.get().getTitle());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Xttblog <span class="title">getBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> blog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后模仿这个线程在实际中的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalTarget target = <span class="keyword">new</span> ThreadLocalTarget();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(target);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 线程加入</span></span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"更改后的名字："</span> + ThreadLocalTarget.getBlog().getTitle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>Thread-0更改后的名字：test<br>main更改后的名字：test</p></blockquote><p>你是不是傻眼了。ThreadLocal 不是会拷贝的变量的一个副本吗？怎么变量的值最终被改变了。</p><p>不，是你没有理解它！</p><h1 id="正确示范"><a href="#正确示范" class="headerlink" title="正确示范"></a>正确示范</h1><p>我们来看看阿里规范中对对ThreadLocal的推荐用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，用到 DateFormat 对象的地方，就要这样获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateUtils.df.get().format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>前面提到过， ThreadLocal 保证的是同一个线程内部调用的各种方法共享当前线程中 ThreadLocal 的变量。就是说针对同一个线程中任何地方访问属于当前现在的共享变量是同一个。从上面也可以看出 ThreadLocal 不是拷贝的变量的副本。</p><p>ThreadLocal 相当于每个线程A在创建的时候，已经为你创建好了一个 DateFormat，这个 DateFormat 在当前这个线程A中共享。其他线程B，再用到 DateFormat 的地方，会<strong>再创建一个 DateFormat 对象</strong>，这个对象会在线程 B 中共享，直到线程 B 结束。</p><p>也就是说 ThreadLocal 的用法和我们自己 new 对象一样，然后将这个 new 的对象传递到各个方法中。但是到处传递的话，太麻烦了。这个时候，就应该用 ThreadLocal。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ThreadLocal 并不是为了解决线程安全问题，而是提供了一种将实例绑定到当前线程的机制，类似于隔离的效果，实际上自己在方法中 new 出来变量也能达到类似的效果。ThreadLocal 跟线程安全基本不搭边，绑定上去的实例也不是多线程公用的，而是每个线程 new 一份，这个实例肯定不是共用的，如果共用了，那就会引发线程安全问题。ThreadLocal 最大的用处就是用来把实例变量共享成全局变量，在程序的任何方法中都可以访问到该实例变量而已。网上很多人说 ThreadLocal 是解决了线程安全问题，其实是望文生义，两者不是同类问题。</p><p>这篇文章只是讲了对ThreadLocal 粗浅的理解以及它的正确用法。接下来的文章会从源码解析ThreadLocal 的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初衷&quot;&gt;&lt;a href=&quot;#初衷&quot; class=&quot;headerlink&quot; title=&quot;初衷&quot;&gt;&lt;/a&gt;初衷&lt;/h1&gt;&lt;p&gt;因为看到有很多人，对ThreadLocal并没有充分的理解，从而出现了很多奇怪的问题，甚至可能在生产环境中出现致命错误。因为ThreadLocal在多线程中的特殊性，往往问题还很难定位到，今天，我就带大家一起来探讨一下ThreadLocal的正确用法。&lt;/p&gt;
&lt;h1 id=&quot;官方解释&quot;&gt;&lt;a href=&quot;#官方解释&quot; class=&quot;headerlink&quot; title=&quot;官方解释&quot;&gt;&lt;/a&gt;官方解释&lt;/h1&gt;&lt;p&gt;要理解 ThreadLocal，先来看看官方对它的解释：&lt;/p&gt;
&lt;p&gt;This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发" scheme="http://itblogs.club/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://itblogs.club/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
